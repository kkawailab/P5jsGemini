# 第8章: (発展) 配列とオブジェクト

おめでとうございます！ここまでの章で、あなたはp5.jsを使ったプログラミングの基本的な要素をすべて学びました。この最終章では、少し発展的な内容として、より多くのデータを効率的に扱うための「配列」と「オブジェクト」という2つの強力なデータ構造を学びます。これらを使いこなせば、たくさんのキャラクターを動かしたり、複雑なパーティクル表現を作ったりと、表現の可能性が無限に広がります。

## 8.1 たくさんのモノを扱うには？

例えば、画面上に100個のボールを、それぞれ違う動きでアニメーションさせたいとします。これまでの知識だと、ボール1つにつき `ballX1`, `ballY1`, `ballSpeed1` のように変数が必要になり、100個分となると変数が300個も必要になってしまいます。これは現実的ではありません。

そこで登場するのが、複数のデータをまとめて管理できる「配列」と「オブジェクト」です。

## 8.2 配列 (Array): データのリスト

配列とは、**複数のデータを順番に並べて格納できる、大きな箱**のようなものです。ちょうど、番号が振られたロッカーや整理棚をイメージしてください。

- 配列の中の各データは「**要素**」と呼びます。
- 各要素には `0` から始まる「**インデックス**」という番号が自動的に振られます。

### 配列の作り方と使い方

`[]`（角括弧）で囲み、要素をカンマで区切って配列を作成します。

```javascript
// 5つの円のx座標を配列で管理する
let circleX = [50, 120, 190, 260, 330];
```

配列の要素にアクセスするには、`配列名[インデックス]` のように書きます。

```javascript
console.log(circleX[0]); // -> 50 (配列の最初の要素)
console.log(circleX[2]); // -> 190 (配列の3番目の要素)

ellipse(circleX[1], 200, 50, 50); // 120の位置に円を描く
```

### 配列と`for`ループ

配列の真価は `for` ループと組み合わせたときに発揮されます。配列の要素数は `配列名.length` で取得できます。

```javascript
let circleX = [50, 120, 190, 260, 330];

function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(220);
  
  // circleX.length は 5 なので、ループは5回繰り返される (iは0から4まで)
  for (let i = 0; i < circleX.length; i++) {
    // iが 0, 1, 2... と変わることで、配列の全要素にアクセスできる
    ellipse(circleX[i], 200, 50, 50);
  }
}
```

## 8.3 オブジェクト (Object): プロパティの集合

オブジェクトとは、**関連するデータを「名前: 値」のペアでまとめて管理する**仕組みです。配列が「番号」でデータを管理するのに対し、オブジェクトは「名前（プロパティ名）」で管理します。

一人のキャラクターの「名前」「HP」「攻撃力」のように、異なる種類の情報をひとまとめにするのに便利です。

### オブジェクトの作り方と使い方

`{}`（波括弧）を使い、`プロパティ名: 値` のペアをカンマで区切ってオブジェクトを作成します。

```javascript
// 1つのボールに関する情報をオブジェクトで管理する
let ball = {
  x: 200,       // x座標
  y: 150,       // y座標
  size: 40,       // 大きさ
  speed: 2,       // スピード
  color: 'red'    // 色
};
```

オブジェクトのプロパティにアクセスするには、`オブジェクト名.プロパティ名` のように書きます。

```javascript
console.log(ball.x); // -> 200
console.log(ball.color); // -> 'red'

// オブジェクトのプロパティを使って円を描画
fill(ball.color);
ellipse(ball.x, ball.y, ball.size, ball.size);

// プロパティの値を更新
ball.x = ball.x + ball.speed;
```

## 8.4 最強の組み合わせ: オブジェクトの配列

配列とオブジェクトを組み合わせることで、非常に強力なデータ管理が可能になります。つまり、**オブジェクトを要素とする配列**を作るのです。

これにより、「たくさんのボール（それぞれが独自の位置やスピードを持つ）」といった複雑な状況を、スッキリと管理できます。

```javascript
// ボール（オブジェクト）を格納するための配列
let balls = [];

function setup() {
  createCanvas(400, 400);
  
  // 10個のボールオブジェクトを作成して、配列に追加する
  for (let i = 0; i < 10; i++) {
    balls.push({
      x: random(width),
      y: random(height),
      size: random(10, 30),
      speedX: random(-2, 2),
      speedY: random(-2, 2)
    });
  }
}

function draw() {
  background(220);
  
  // 配列内のすべてのボールに対して処理を行う
  for (let i = 0; i < balls.length; i++) {
    // i番目のボールオブジェクトを取得
    let b = balls[i];
    
    // ボールを動かす
    b.x = b.x + b.speedX;
    b.y = b.y + b.speedY;
    
    // ボールを描画する
    ellipse(b.x, b.y, b.size, b.size);
  }
}
```
`balls.push(...)` は、配列の末尾に新しい要素を追加する命令です。

---

## 章末問題

### 問題1
`setup()`の中で、`for`ループを使って10個のランダムな数値（0〜400の範囲）を生成し、それらを `starX` という配列に格納してください。`draw()`の中で、その配列を使って、y座標は200に固定し、x座標だけがランダムな10個の星（小さな円でOK）を描画してください。

<details>
<summary>解答</summary>

```javascript
let starX = [];

function setup() {
  createCanvas(400, 400);
  
  // 10個のランダムなx座標を配列に格納
  for (let i = 0; i < 10; i++) {
    starX.push(random(width));
  }
}

function draw() {
  background(0); // 夜空
  fill(255, 255, 0);
  noStroke();
  
  // 配列のデータを使って星を描画
  for (let i = 0; i < starX.length; i++) {
    ellipse(starX[i], 200, 5, 5);
  }
}
```
</details>

### 問題2
雨粒を表現するオブジェクトの配列を使って、雨が降るアニメーションを作成してみましょう。
1. `setup()`で、空の配列 `raindrops` を作成します。
2. `draw()`の中で、`for`ループを使い、`raindrops`配列のすべての雨粒を下に動かし、描画します。
3. `draw()`の中で、毎回（あるいは数フレームに1回）、新しい雨粒オブジェクトを `raindrops` 配列に `push()` で追加します。

<details>
<summary>解答</summary>

```javascript
let raindrops = [];

function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(220);
  
  // 新しい雨粒を配列に追加
  raindrops.push({
    x: random(width),
    y: 0,
    speed: random(2, 5)
  });
  
  // すべての雨粒を処理
  for (let i = 0; i < raindrops.length; i++) {
    let rain = raindrops[i];
    
    // 雨粒を動かす
    rain.y = rain.y + rain.speed;
    
    // 雨粒を描画
    stroke(0, 0, 255);
    line(rain.x, rain.y, rain.x, rain.y + 10);
  }
}
```
※このままだと配列が無限に増え続けるので、画面外に出た雨粒を配列から削除する処理を入れると、より本格的になります。
</details>

これでチュートリアルは終わりです。たくさんのことを学びましたが、これはクリエイティブ・コーディングの世界のほんの入り口です。ぜひ、ここで学んだ知識を組み合わせて、あなただけのオリジナル作品を作ってみてください！